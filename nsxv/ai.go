/*
 * NSX-V
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nsxv

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AiApiService service

/*
AiApiService specificAppDetailsRead
Retrieve details for specific app.  Parameters:  appID: Specified app ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appID

*/
func (a *AiApiService) AiAppAppIDGet(ctx context.Context, appID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/app/{appID}"
	lPath = strings.Replace(lPath, "{"+"appID"+"}", fmt.Sprintf("%v", appID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService appDetailsRead
Retrieve app details.  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiAppGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/app"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificDesktopPoolRead
Retrieve specific desktop pool details.  Parameters:  desktoppoolID: Specified desktop pool.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param desktoppoolID

*/
func (a *AiApiService) AiDesktoppoolDesktoppoolIDGet(ctx context.Context, desktoppoolID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/desktoppool/{desktoppoolID}"
	lPath = strings.Replace(lPath, "{"+"desktoppoolID"+"}", fmt.Sprintf("%v", desktoppoolID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService desktopPoolRead
Retrieve list of all discovered desktop pools by agent introspection.   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiDesktoppoolGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/desktoppool"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificDirGroupRead
Retrieve details about a specific directory group.  Parameters:  directorygroupID: Specified directory group.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param directorygroupID

*/
func (a *AiApiService) AiDirectorygroupDirectorygroupIDGet(ctx context.Context, directorygroupID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/directorygroup/{directorygroupID}"
	lPath = strings.Replace(lPath, "{"+"directorygroupID"+"}", fmt.Sprintf("%v", directorygroupID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService dirGroupRead
Retrieve list of all discovered (and configured) LDAP directory groups.   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiDirectorygroupGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/directorygroup"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService userDirGroupRead
Retrieve Active Directory groups that user belongs to.  Parameters:  userID: User ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userID

*/
func (a *AiApiService) AiDirectorygroupUserUserIDGet(ctx context.Context, userID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/directorygroup/user/{userID}"
	lPath = strings.Replace(lPath, "{"+"userID"+"}", fmt.Sprintf("%v", userID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService hostDetailsRead
Retrieve list of all discovered hosts (both by agent introspection and LDAP Sync) and their detail.   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiHostGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/host"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificHostDetailsRead
Get host details.  Parameters:  hostID: Specified host ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param hostID

*/
func (a *AiApiService) AiHostHostIDGet(ctx context.Context, hostID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/host/{hostID}"
	lPath = strings.Replace(lPath, "{"+"hostID"+"}", fmt.Sprintf("%v", hostID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService userActivityRead
### View Outbound Activity  You can view what applications are being run by a security group or desktop pool and then drill down into the report to find out which client applications are making outbound connections by a particular group of users. You can also discover all user groups and users who are accessing a particular application, which can help you determine if you need to adjust identity firewall in your environment.  * query&#x3D;*resource* * param&#x3D;&amp;lt;param-name&amp;gt;:&amp;lt;param-type&amp;gt;:&amp;lt;comma-separated-values&amp;gt;:&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)     * *app*   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *VIRTUAL_MACHINE*     * for app: *SRC_APP*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE* (default is *INCLUDE*).  **Example:** View user activities to VM ID 1 originating from application ID 1   &#x60;GET /api/3.0/ai/records?query&#x3D;resource&amp;interval&#x3D;60m&amp;param&#x3D;src:DIRECTORY_GROUP&#x60;   &#x60;&amp;param&#x3D;dest:VIRTUAL_MACHINE:1&amp;param&#x3D;app:SRC_APP:1&#x60;  ### View Inbound Activity  You can view all inbound activity to a server by desktop pool, security group, or AD group.  * query&#x3D;*sam* * param&#x3D;&amp;lt;param-name&amp;gt;:&amp;lt;param-type&amp;gt;:&amp;lt;comma-separated-values&amp;gt;:&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)     * *app*   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *VIRTUAL_MACHINE*     * for app: *DEST_APP*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE*, *NOT* (default is *INCLUDE*).  **Example:** View user activities to VM ID 1 originating from application ID 1   &#x60;GET /api/3.0/ai/records?query&#x3D;containers&amp;interval&#x3D;60m&amp;param&#x3D;dest:SECURITY_GROUP:1:EXCLUDE&#x60;   &#x60;&amp;param&#x3D;src:SECURITY_GROUP:1&#x60;  ### View Interaction between Inventory Containers You can view the traffic passing between defined containers such as AD groups, security groups and/or desktop pools. This can help you identify and configure access to shared services and to resolve misconfigured relationships between Inventory container definitions, desktop pools and AD groups.  * query&#x3D;*containers* * param&#x3D;&amp;lt;param-name&amp;gt;:&amp;lt;param-type&amp;gt;:&amp;lt;comma-separated-values&amp;gt;:&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *SECURITY_GROUP*, * *DESKTOP_POOL*    * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE*, or *NOT* (default * is *INCLUDE*).  **Example:** View interaction between inventory containers   &#x60;GET /api/3.0/ai/records?query&#x3D;containers&amp;interval&#x3D;60m&amp;param&#x3D;dest:SECURITY_GROUP:1:EXCLUDE&#x60;   &#x60;&amp;param&#x3D;src:SECURITY_GROUP:1&#x60;  ### View Outbound AD Group Activity  You can view the traffic between members of defined Active Directory groups and can use this data to fine tune your firewall rules.  * query&#x3D;*adg* * param&#x3D;&amp;lt;param-name&amp;gt;:&amp;lt;param-type&amp;gt;:&amp;lt;comma-separated-values&amp;gt;:&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *adg*   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DESKTOP_POOL*     * for adg: *USER*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE* (default * is *INCLUDE*).  **Example:** View outbound AD group activity     &#x60;GET https://NSX-Manager-IP-Address/api/3.0/ai/records?query&#x3D;adg&amp;interval&#x3D;24h&amp;param&#x3D;adg:USER:1:INCLUDE&#x60;   &#x60;&amp;param&#x3D;src:SECURITY_GROUP:1:EXCLUDE&#x60;   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AiApiAiRecordsGetOpts - Optional Parameters:
     * @param "Query" (optional.String) -
     * @param "Interval" (optional.String) -
     * @param "Stime" (optional.String) -
     * @param "Etime" (optional.String) -
     * @param "Param" (optional.String) -
     * @param "Pagesize" (optional.String) -
     * @param "Startindex" (optional.String) -

*/

type AiApiAiRecordsGetOpts struct {
	Query      optional.String
	Interval   optional.String
	Stime      optional.String
	Etime      optional.String
	Param      optional.String
	Pagesize   optional.String
	Startindex optional.String
}

func (a *AiApiService) AiRecordsGet(ctx context.Context, lOptionals *AiApiAiRecordsGetOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/records"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	if lOptionals != nil && lOptionals.Query.IsSet() {
		lQueryParams.Add("query", parameterToString(lOptionals.Query.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Interval.IsSet() {
		lQueryParams.Add("interval", parameterToString(lOptionals.Interval.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Stime.IsSet() {
		lQueryParams.Add("stime", parameterToString(lOptionals.Stime.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Etime.IsSet() {
		lQueryParams.Add("etime", parameterToString(lOptionals.Etime.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Param.IsSet() {
		lQueryParams.Add("param", parameterToString(lOptionals.Param.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Pagesize.IsSet() {
		lQueryParams.Add("pagesize", parameterToString(lOptionals.Pagesize.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Startindex.IsSet() {
		lQueryParams.Add("startindex", parameterToString(lOptionals.Startindex.Value(), ""))
	}
	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService secgroupDetailsRead
Retrieve list of all observed security groups.  Observed entities are the ones that are reported by the agents. For example, if a host activity is reported by an agent and if that host belongs to a security group then that security group would reported as observed in SAM database.   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiSecuritygroupGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/securitygroup"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificSecgroupDetailsRead
Retrieve details about specific security group.  Parameters:  secgroupID: Specified security group.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param secgroupID

*/
func (a *AiApiService) AiSecuritygroupSecgroupIDGet(ctx context.Context, secgroupID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/securitygroup/{secgroupID}"
	lPath = strings.Replace(lPath, "{"+"secgroupID"+"}", fmt.Sprintf("%v", secgroupID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificUserDetailsRead
Retrieve details for a specific user.  Parameters:  userID: User ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userID

*/
func (a *AiApiService) AiUserUserIDGet(ctx context.Context, userID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/user/{userID}"
	lPath = strings.Replace(lPath, "{"+"userID"+"}", fmt.Sprintf("%v", userID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService userDetailsRead
### View Outbound Activity You can view what applications are being run by a security group or desktop pool and then drill down into the report to find out which client applications are making outbound connections by a particular group of users. You can also discover all user groups and users who are accessing a particular application, which can help you determine if you need to adjust identity firewall in your environment.  * query&#x3D;*resource* * param&#x3D;&amp;lt;param-name&amp;gt;&amp;lt;param-type&amp;gt;&amp;lt;comma-separated-values&amp;gt;&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)     * *app*   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *IP* - a valid IP address in dot notation, xx.xx.xx.xx     * for app: *SRC_APP*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE* (default is *INCLUDE*).  **Example:** View user activities to VM ID 1 originating from application ID 1   &#x60;GET /api/3.0/ai/userdetails?query&#x3D;resource&amp;stime&#x3D;2012-10-15T00:00:00&amp;etime&#x3D;2012-10-20T00:00:00&#x60;   &#x60;&amp;param&#x3D;src:DIRECTORY_GROUP:2&amp;param&#x3D;app:SRC_APP:16&amp;param&#x3D;dest:IP:172.16.4.52&#x60;  ### View Inbound Activity  You can view all inbound activity to a server by desktop pool, security group, or AD group.  * query&#x3D;*sam* * param&#x3D;&amp;lt;param-name&amp;gt;&amp;lt;param-type&amp;gt;&amp;lt;comma-separated-values&amp;gt;&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)     * *app* (required)   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *VIRTUAL_MACHINE*     * for app: *DEST_APP*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE*, *NOT* (default is *INCLUDE*).  **Example:** View user activities to VM ID 1 originating from application ID 1   &#x60;GET /api/3.0/userdetails?query&#x3D;sam&amp;interval&#x3D;60m&amp;param&#x3D;app:DEST_APP:1:EXCLUDE&#x60;   &#x60;&amp;param&#x3D;dest:IP:1:EXCLUDE&amp;param&#x3D;src:SECURITY_GROUP:1:EXCLUDE&#x60;  ### View Interaction between Inventory Containers You can view the traffic passing between defined containers such as AD groups, security groups and/or desktop pools. This can help you identify and configure access to shared services and to resolve misconfigured relationships between Inventory container definitions, desktop pools and AD groups.  * query&#x3D;*containers* * param&#x3D;&amp;lt;param-name&amp;gt;&amp;lt;param-type&amp;gt;&amp;lt;comma-separated-values&amp;gt;&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *dest* (required)   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DIRECTORY_GROUP*, *DESKTOP_POOL*     * for dest: *SECURITY_GROUP*, * *DESKTOP_POOL*    * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE*, or *NOT* (default * is *INCLUDE*).  **Example:** View interaction between inventory containers   &#x60;GET /api/3.0/ai/userdetails?query&#x3D;containers&amp;interval&#x3D;60m&amp;param&#x3D;dest:SECURITY_GROUP:1:EXCLUDE&#x60;   &#x60;&amp;param&#x3D;src:SECURITY_GROUP:1&#x60;  ### View Outbound AD Group Activity  You can view the traffic between members of defined Active Directory groups and can use this data to fine tune your firewall rules.  * query&#x3D;*adg* * param&#x3D;&amp;lt;param-name&amp;gt;&amp;lt;param-type&amp;gt;&amp;lt;comma-separated-values&amp;gt;&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src* (required)     * *adg*   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DESKTOP_POOL*     * for adg: *USER*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE* (default is *INCLUDE*).  **Example:** View outbound AD group activity     &#x60;GET /api/3.0/ai/userdetails?query&#x3D;adg&amp;interval&#x3D;24h&amp;param&#x3D;adg:USER:1:INCLUDE&#x60;   &#x60;&amp;param&#x3D;src:SECURITY_GROUP:1:EXCLUDE&#x60;  ### View Virtual Machine Activity Report  * query&#x3D;*vma* * param&#x3D;&amp;lt;param-name&amp;gt;&amp;lt;param-type&amp;gt;&amp;lt;comma-separated-values&amp;gt;&amp;lt;operator&amp;gt;, where:   * &amp;lt;param-name&amp;gt; is one of:     * *src*     * *dst*     * *app*     * If no parameters are passed, then this would show all SAM     activities   * &amp;lt;param-type&amp;gt; is one of:     * for src: *SECURITY_GROUP*, *DESKTOP_POOL*     * for dst: *VIRTUAL_MACHINE*, *VM_UUID*     * for app - *SRC_APP* or *DEST_APP*   * &amp;lt;comma-separated-values&amp;gt; is a comma-separated numbers (optional). If none specified then no filter is applied.   * &amp;lt;operator&amp;gt; is one of *INCLUDE*, *EXCLUDE* (default is *INCLUDE*).  **Example:** View outbound AD group activity     &#x60;GET /api/3.0/ai/userdetails?query&#x3D;vma&amp;interval&#x3D;60m&amp;param&#x3D;dest:VIRTUAL_MACHINE:1 &amp;param&#x3D;app:DEST_APP:16&#x60;   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AiApiAiUserdetailsGetOpts - Optional Parameters:
     * @param "Query" (optional.String) -
     * @param "Interval" (optional.String) -
     * @param "Stime" (optional.String) -
     * @param "Etime" (optional.String) -
     * @param "Param" (optional.String) -
     * @param "Pagesize" (optional.String) -
     * @param "Startindex" (optional.String) -

*/

type AiApiAiUserdetailsGetOpts struct {
	Query      optional.String
	Interval   optional.String
	Stime      optional.String
	Etime      optional.String
	Param      optional.String
	Pagesize   optional.String
	Startindex optional.String
}

func (a *AiApiService) AiUserdetailsGet(ctx context.Context, lOptionals *AiApiAiUserdetailsGetOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/userdetails"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	if lOptionals != nil && lOptionals.Query.IsSet() {
		lQueryParams.Add("query", parameterToString(lOptionals.Query.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Interval.IsSet() {
		lQueryParams.Add("interval", parameterToString(lOptionals.Interval.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Stime.IsSet() {
		lQueryParams.Add("stime", parameterToString(lOptionals.Stime.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Etime.IsSet() {
		lQueryParams.Add("etime", parameterToString(lOptionals.Etime.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Param.IsSet() {
		lQueryParams.Add("param", parameterToString(lOptionals.Param.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Pagesize.IsSet() {
		lQueryParams.Add("pagesize", parameterToString(lOptionals.Pagesize.Value(), ""))
	}
	if lOptionals != nil && lOptionals.Startindex.IsSet() {
		lQueryParams.Add("startindex", parameterToString(lOptionals.Startindex.Value(), ""))
	}
	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService vmDetailsRead
Retrieve list of all discovered VMs.  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *AiApiService) AiVmGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/vm"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
AiApiService specificVMDetailsRead
Retrieve details about a specific virtual machine.  Parameters:  vmID: VM ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param vmID

*/
func (a *AiApiService) AiVmVmIDGet(ctx context.Context, vmID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/3.0/ai/vm/{vmID}"
	lPath = strings.Replace(lPath, "{"+"vmID"+"}", fmt.Sprintf("%v", vmID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}
