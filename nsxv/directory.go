/*
 * NSX-V
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nsxv

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type DirectoryApiService service

/*
DirectoryApiService domainDeleteDelete
Delete domain.  Parameters:  ID: Domain ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param iD

*/
func (a *DirectoryApiService) DirectoryDeleteDomainIDDelete(ctx context.Context, iD string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Delete")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/deleteDomain/{ID}"
	lPath = strings.Replace(lPath, "{"+"ID"+"}", fmt.Sprintf("%v", iD), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService eLogServerDeleteDelete
Delete EventLog server.  Parameters:  serverID: Specified EventLog server ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverID

*/
func (a *DirectoryApiService) DirectoryDeleteEventLogServerServerIDDelete(ctx context.Context, serverID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Delete")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/deleteEventLogServer/{serverID}"
	lPath = strings.Replace(lPath, "{"+"serverID"+"}", fmt.Sprintf("%v", serverID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService ldapServerDeleteDelete
Delete LDAP server.  Parameters:  serverID: Specified LDAP server.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverID

*/
func (a *DirectoryApiService) DirectoryDeleteLdapServerServerIDDelete(ctx context.Context, serverID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Delete")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/deleteLdapServer/{serverID}"
	lPath = strings.Replace(lPath, "{"+"serverID"+"}", fmt.Sprintf("%v", serverID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService ldapServerDeltaSyncExecute
Start LDAP delta sync.  Parameters:  domainID: Specified domain.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domainID

*/
func (a *DirectoryApiService) DirectoryDeltaSyncDomainIDPut(ctx context.Context, domainID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Put")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/deltaSync/{domainID}"
	lPath = strings.Replace(lPath, "{"+"domainID"+"}", fmt.Sprintf("%v", domainID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService ldapServerSyncExecute
Start LDAP full sync.  Parameters:  domainID: Specified domain.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domainID

*/
func (a *DirectoryApiService) DirectoryFullSyncDomainIDPut(ctx context.Context, domainID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Put")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/fullSync/{domainID}"
	lPath = strings.Replace(lPath, "{"+"domainID"+"}", fmt.Sprintf("%v", domainID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService domainListRead
Retrieve all agent discovered (or configured) LDAP domains.  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *DirectoryApiService) DirectoryListDomainsGet(ctx context.Context) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/listDomains"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService eLogServerDomainReadRead
Query EventLog servers for a domain.  Parameters:  domainID: Specified domain.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domainID

*/
func (a *DirectoryApiService) DirectoryListEventLogServersForDomainDomainIDGet(ctx context.Context, domainID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/listEventLogServersForDomain/{domainID}"
	lPath = strings.Replace(lPath, "{"+"domainID"+"}", fmt.Sprintf("%v", domainID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService ldapServerDomainRead
Query LDAP servers for a domain.  Parameters:  domainID: Specified domain.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domainID

*/
func (a *DirectoryApiService) DirectoryListLdapServersForDomainDomainIDGet(ctx context.Context, domainID string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/listLdapServersForDomain/{domainID}"
	lPath = strings.Replace(lPath, "{"+"domainID"+"}", fmt.Sprintf("%v", domainID), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService domainCreate
Register or update a domain with NSX Manager  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DirectoryApiDirectoryUpdateDomainPostOpts - Optional Parameters:
     * @param "Body" (optional.Interface of interface{}) -
     * @param "ContentType" (optional.String) -

*/

type DirectoryApiDirectoryUpdateDomainPostOpts struct {
	Body        optional.Interface
	ContentType optional.String
}

func (a *DirectoryApiService) DirectoryUpdateDomainPost(ctx context.Context, lOptionals *DirectoryApiDirectoryUpdateDomainPostOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Post")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/updateDomain"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	if lOptionals != nil && lOptionals.ContentType.IsSet() {
		lHeaderParams["Content-Type"] = parameterToString(lOptionals.ContentType.Value(), "")
	}
	// body params
	if lOptionals != nil && lOptionals.Body.IsSet() {

		lOptionalBody := lOptionals.Body.Value()
		lPostBody = &lOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService eLogServerCreateCreate
Create EventLog server.  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DirectoryApiDirectoryUpdateEventLogServerPostOpts - Optional Parameters:
     * @param "Body" (optional.Interface of interface{}) -
     * @param "ContentType" (optional.String) -

*/

type DirectoryApiDirectoryUpdateEventLogServerPostOpts struct {
	Body        optional.Interface
	ContentType optional.String
}

func (a *DirectoryApiService) DirectoryUpdateEventLogServerPost(ctx context.Context, lOptionals *DirectoryApiDirectoryUpdateEventLogServerPostOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Post")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/updateEventLogServer"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	if lOptionals != nil && lOptionals.ContentType.IsSet() {
		lHeaderParams["Content-Type"] = parameterToString(lOptionals.ContentType.Value(), "")
	}
	// body params
	if lOptionals != nil && lOptionals.Body.IsSet() {

		lOptionalBody := lOptionals.Body.Value()
		lPostBody = &lOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
DirectoryApiService ldapServerCreateCreate
Create LDAP server.  Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DirectoryApiDirectoryUpdateLdapServerPostOpts - Optional Parameters:
     * @param "Body" (optional.Interface of interface{}) -
     * @param "ContentType" (optional.String) -

*/

type DirectoryApiDirectoryUpdateLdapServerPostOpts struct {
	Body        optional.Interface
	ContentType optional.String
}

func (a *DirectoryApiService) DirectoryUpdateLdapServerPost(ctx context.Context, lOptionals *DirectoryApiDirectoryUpdateLdapServerPostOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Post")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/directory/updateLdapServer"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	if lOptionals != nil && lOptionals.ContentType.IsSet() {
		lHeaderParams["Content-Type"] = parameterToString(lOptionals.ContentType.Value(), "")
	}
	// body params
	if lOptionals != nil && lOptionals.Body.IsSet() {

		lOptionalBody := lOptionals.Body.Value()
		lPostBody = &lOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}
