/*
 * NSX-V
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nsxv

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type CliApiService service

/*
CliApiService nsxCliExecute
The central command-line interface (central CLI) commands are run from the NSX Manager command line, and retrieve information from the NSX Manager and other devices. These commands can also be executed in the API.  You can insert any valid Central CLI command as the **command** parameter. For a complete list of the Central CLI commands executable through the API, please see the Central CLI chapter of the *NSX Command Line Interface Reference*.   Parameters:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CliApiNsxCliPostOpts - Optional Parameters:
     * @param "Body" (optional.Interface of interface{}) -
     * @param "Accept" (optional.String) -
     * @param "ContentType" (optional.String) -
     * @param "Action" (optional.String) -

*/

type CliApiNsxCliPostOpts struct {
	Body        optional.Interface
	Accept      optional.String
	ContentType optional.String
	Action      optional.String
}

func (a *CliApiService) NsxCliPost(ctx context.Context, lOptionals *CliApiNsxCliPostOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Post")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/1.0/nsx/cli"

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	if lOptionals != nil && lOptionals.Action.IsSet() {
		lQueryParams.Add("action", parameterToString(lOptionals.Action.Value(), ""))
	}
	// to determine the Content-Type header
	lHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	if lOptionals != nil && lOptionals.Accept.IsSet() {
		lHeaderParams["Accept"] = parameterToString(lOptionals.Accept.Value(), "")
	}
	if lOptionals != nil && lOptionals.ContentType.IsSet() {
		lHeaderParams["Content-Type"] = parameterToString(lOptionals.ContentType.Value(), "")
	}
	// body params
	if lOptionals != nil && lOptionals.Body.IsSet() {

		lOptionalBody := lOptionals.Body.Value()
		lPostBody = &lOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}
