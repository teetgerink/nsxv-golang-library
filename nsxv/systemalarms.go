/*
 * NSX-V
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nsxv

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SystemalarmsApiService service

/*
SystemalarmsApiService servicesSystemAlarmsIdRead
Retrieve information about the specified alarm.  **Method history:**  Release | Modification --------|------------- 6.3.0 | Method introduced.   Parameters:  alarmId: The alarm ID you want to manage. Find the alarm ID using the &#x60;GET /api/2.0/services/alarms/{source-Id}&#x60; method.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param alarmId

*/
func (a *SystemalarmsApiService) ServicesSystemalarmsAlarmIdGet(ctx context.Context, alarmId string) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Get")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/2.0/services/systemalarms/{alarmId}"
	lPath = strings.Replace(lPath, "{"+"alarmId"+"}", fmt.Sprintf("%v", alarmId), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	// to determine the Content-Type header
	lHttpContentTypes := []string{}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}

/*
SystemalarmsApiService servicesSystemAlarmsIdAction
Resolve the specified alarm.  Alarms will resolve automatically when the cause of the alarm is resolved.  For example, if an NSX Edge appliance is powered off, this will trigger an alarm. If you power the NSX Edge appliance back on, the alarm will resolve. If however, you delete the NSX Edge appliance, the alarm will persist, because the alarm cause was never resolved. In this case, you may want to manually resolve the alarm. Resolving the alarm  will clear it from the NSX dashboard.  **Method history:**  Release | Modification --------|------------- 6.3.0 | Method introduced.   Parameters:  alarmId: The alarm ID you want to manage. Find the alarm ID using the &#x60;GET /api/2.0/services/alarms/{source-Id}&#x60; method.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param alarmId
 * @param optional nil or *SystemalarmsApiServicesSystemalarmsAlarmIdPostOpts - Optional Parameters:
     * @param "Action" (optional.String) -

*/

type SystemalarmsApiServicesSystemalarmsAlarmIdPostOpts struct {
	Action optional.String
}

func (a *SystemalarmsApiService) ServicesSystemalarmsAlarmIdPost(ctx context.Context, alarmId string, lOptionals *SystemalarmsApiServicesSystemalarmsAlarmIdPostOpts) (*http.Response, error) {
	var (
		lHttpMethod = strings.ToUpper("Post")
		lPostBody   interface{}
		lFileName   string
		lFileBytes  []byte
	)

	// create path and map variables
	lPath := a.client.cfg.BasePath + "/api/2.0/services/systemalarms/{alarmId}"
	lPath = strings.Replace(lPath, "{"+"alarmId"+"}", fmt.Sprintf("%v", alarmId), -1)

	lHeaderParams := make(map[string]string)
	lQueryParams := url.Values{}
	lFormParams := url.Values{}

	if lOptionals != nil && lOptionals.Action.IsSet() {
		lQueryParams.Add("action", parameterToString(lOptionals.Action.Value(), ""))
	}
	// to determine the Content-Type header
	lHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	lHttpContentType := selectHeaderContentType(lHttpContentTypes)
	if lHttpContentType != "" {
		lHeaderParams["Content-Type"] = lHttpContentType
	}

	// to determine the Accept header
	lHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	lHttpHeaderAccept := selectHeaderAccept(lHttpHeaderAccepts)
	if lHttpHeaderAccept != "" {
		lHeaderParams["Accept"] = lHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, lPath, lHttpMethod, lPostBody, lHeaderParams, lQueryParams, lFormParams, lFileName, lFileBytes)
	if err != nil {
		return nil, err
	}

	lHttpResponse, err := a.client.callAPI(r)
	if err != nil || lHttpResponse == nil {
		return lHttpResponse, err
	}

	lBody, err := ioutil.ReadAll(lHttpResponse.Body)
	lHttpResponse.Body.Close()
	if err != nil {
		return lHttpResponse, err
	}

	if lHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  lBody,
			error: lHttpResponse.Status,
		}
		return lHttpResponse, newErr
	}

	return lHttpResponse, nil
}
